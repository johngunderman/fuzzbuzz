
\section{This is a Hard Problem}
\label{hard}

Generating strings from an attribute grammar is NP-Complete.

\subparagraph{Outline}

\begin{enumerate}[1.]
\item
  Reduction 3SAT -\textgreater{} AGSG {[}Shows AGSG at least NP-Hard{]}
\item
  Proof of Poly-Time Verifiable Certificate {[}AGSG in NP{]}
\end{enumerate}
Since AGSG is NP-Hard and it is in NP it is NP-Complete.

\subsubsection{Decision Problem}

Is the language generated by this grammar the empty language?

\subsection{Reduction, 3SAT -\textgreater{} AGSG {[}Attribute Grammar
String Generation{]}}

\subsubsection{Construct a grammar for the 3SAT instance}

eg.

\begin{verbatim}
(x1 || x2 || x3) && (x2 || ~x3 || x4) ... (x2 || x3 || x4)
\end{verbatim}
becomes

\begin{verbatim}
SAT -> AndsM ;

AndM -> AndsM-1 AND ClauseM ;
...
And2 -> Ands1 AND Clause2 ;
And1 -> Clause1 ;

Clause1 -> '(' x1 OR x2 OR x3 ')' ;
Clause2 -> '(' x2 OR NOT x3 OR x4 ')' ;
...
ClauseM -> '(' x2 OR x3 OR x4 ')' ;

x1 -> TRUE
    | FALSE
    ;
x2 -> TRUE
    g| FALSE
    ;
...
xN -> TRUE
    | FALSE
    ;
\engd{verbatim}
With attributes which synthesize the values for each clause and with a
condition which asserts that the whole expression is true.

\begin{verbatim}
SAT -> AndsM
       with Condition {
         AndsM.value == True
       }
       ;

AndM -> AndsM-1 AND ClauseM
         with Action {
            AndsM.value = AndM-1.value && ClauseM.value
            AndsM.names = {
              ClauseM.a.name:ClauseM.a.value,
              ClauseM.b.name:ClauseM.b.value,
              ClauseM.c.name:ClauseM.c.value
            }
            AndsM.names = AndsM.names | AndsM-1.names
         }
         with Condition {
           (ClauseM.a.name != ClauseM.b.name ||
             ClauseM.a.value == ClauseM.b.value) &&
           (ClauseM.c.name != ClauseM.b.name ||
             ClauseM.c.value == ClauseM.b.value) &&
           (ClauseM.a.name != ClauseM.c.name ||
             ClauseM.a.value == ClauseM.c.value) &&
           (ClauseM.a.name not in AndsM-1.names ||
             ClauseM.a.value == AndsM-1.names[ClauseM.a.name]) &&
           (ClauseM.b.name not in AndsM-1.names ||
             ClauseM.b.value == AndsM-1.names[ClauseM.b.name]) &&
           (ClauseM.c.name not in AndsM-1.names ||
             ClauseM.c.value == AndsM-1.names[ClauseM.c.name])
         }
         ;
...
And2 -> Ands1 AND Clause2
         with Action {
            Ands2.value = Ands1.value && Clause2.value
            Ands2.names = {
              Clause2.a.name:Clause2.a.value,
              Clause2.b.name:Clause2.b.value,
              Clause2.c.name:Clause2.c.value
            }
            Ands2.names = Ands2.names | Ands1.names
         }
         with Condition {
           (Clause2.a.name != Clause2.b.name ||
             Clause2.a.value == Clause2.b.value) &&
           (Clause2.c.name != Clause2.b.name ||
             Clause2.c.value == Clause2.b.value) &&
           (Clause2.a.name != Clause2.c.name ||
             Clause2.a.value == Clause2.c.value) &&
           (Clause2.a.name not in Ands1.names ||
             Clause2.a.value == Ands1.names[Clause2.a.name]) &&
           (Clause2.b.name not in Ands1.names ||
             Clause2.b.value == Ands1.names[Clause2.b.name]) &&
           (Clause2.c.name not in Ands1.names ||
             Clause2.c.value == Ands1.names[Clause2.c.name])
         }
         ;
And1 -> Clause1
         with Action {
            Ands1.value = Clause1.value
            Ands1.names = {
              Clause1.a.name:Clause1.a.value,
              Clause1.b.name:Clause1.b.value,
              Clause1.c.name:Clause1.c.value
            }
         }
         with Condition {
           (Clause1.a.name != Clause1.b.name ||
             Clause1.a.value == Clause1.b.value) &&
           (Clause1.c.name != Clause1.b.name ||
             Clause1.c.value == Clause1.b.value) &&
           (Clause1.a.name != Clause1.c.name ||
             Clause1.a.value == Clause1.c.value)
         }
         ;

Clause1 -> '(' x1 OR x2 OR x3 ')'
           with Action {
             Clause1.value = x1.value || x2.value || x3.value
             Clause1.a.name = 'x1'
             Clause1.a.value = x1.value
             Clause1.b.name = 'x2'
             Clause1.b.value = x2.value
             Clause1.c.name = 'x3'
             Clause1.c.value = x3.value
           }
           ;
Clause2 -> '(' x2 OR NOT x3 OR x4 ')'
           with Action {
             Clause2.value = x2.value || !x3.value || x4.value
             Clause2.a.name = 'x2'
             Clause2.a.value = x2.value
             Clause2.b.name = 'x3'
             Clause2.b.value = x3.value
             Clause2.c.name = 'x4'
             Clause2.c.value = x4.value
           }
           ;
...
ClauseM -> '(' x2 OR x3 OR x4 ')'
           with Action {
             ClauseM.value = x2.value || x3.value || x4.value
             ClauseM.a.name = 'x2'
             ClauseM.a.value = x2.value
             ClauseM.b.name = 'x3'
             ClauseM.b.value = x3.value
             ClauseM.c.name = 'x4'
             ClauseM.c.value = x4.value
           }
           ;

x1 -> TRUE
      with Action {
        x1.value = True
      }
    | FALSE
      with Action {
        x1.value = False
      }
    ;
x2 -> TRUE
      with Action {
        x1.value = True
      }
    | False
      with Action {
        x1.value = False
      }
    ;
...
xN -> TRUE
      with Action {
        x1.value = True
      }
    | FALSE
      with Action {
        x1.value = False
      }
    ;
\end{verbatim}
This translation from 3SAT to AGSG is clearly poly time.
O(\textbar{}C\textbar{} + \textbar{}V\textbar{}) where C = the clauses
in 3SAT and V = the variables.

\subsubsection{Show a solution for 3SAT ---\textgreater{} creates a
parsable string for AGSG}

In a solution for 3SAT all names (x1, x2, \ldots{} xN) always have
exactly one value (True or False) assigned to them. The condition on
each ``AndX'' production {[}And1, And2 \ldots{}{]} states that each name
always has the same value. That is once xN has recieved a value (True or
False) all other instances of xN must have the same value. Therefore,
all conditions are the AndX clauses are satisfied by any solution to
3SAT by the definition of a 3SAT solution.

The actions on each variable production (x1, x2, \ldots{} xN) produce a
value, eg. \verb!x1.value!, either equal to True or False. The actions
on each clause production (Clause1, Clause2, \ldots{} ClauseN) combine
the values of the variables in that clause together. They combine them
in the same way they are combined in the equivalent clause in 3SAT by
construction.

Finally the chain of And productions (And1, And2, \ldots{} AndN) combine
the values synthesized by the clauses (\verb!Clause1.value!,
\verb!Clause2.value!, \ldots{} \verb!ClauseN.value!). Into a final value
\verb!AndN.value! via:

\begin{verbatim}
And1.value = Clause1.value
And2.value = And1.value && Clause2.value
And3.value = And2.value && Clause3.value
...
AndN.value = AndN-1.value && ClauseN.value
\end{verbatim}
which can be reduced to 1 expression with algebraic substitution as:

\begin{verbatim}
AndN.value = Clause1.value && Clause2.value && ... && ClauseN.value
\end{verbatim}
Which synthesizes the same value which the 3SAT problem specifies. Once
again by construction.

Therefore, if a variable assignment satisfies 3SAT then it must also
synthesize a value of \verb!True! on \verb!AndN.value! resulting in a
parsable expression.

\subsubsection{Show a string generated by the grammar ---\textgreater{}
is a solution for 3SAT}

In the above proof, we showed that the attributes on the grammar compute
the same answer as algebraically evaulating the 3SAT expression. Since
(once again by the above proof) there is a unique variable assignment in
the generated string this string must evaluate to True. If it didn't it
could not have been generated by the grammar. Therefore, the string
generated corresponds to a unique variable assignment in 3SAT which
causes the expression to evaluate to True.

\subsection{AGSG is in NP}

\paragraph{Certificate}

A string of terminal symbols.

\subsection{Show the Certificate can be Verified in Poly-Time}

\subsubsection{The Algorithm for Verification}

\begin{itemize}
\item
  Transform the Context-Free grammar into Chomsky Normal Form. This
  ensures a polynomial tree height with each Non-Terminal symbol having
  at most 2 children.
\item
  Using the Chomsky Normal Form Context-Free version of the grammar
  parse the string and transform it into a parse tree.
\item
  Using a Post-Order tree traversal to apply the actions and check the
  conditions of each grammar rule
\end{itemize}
\subsubsection{Proof Alg. in Poly-Time}

Since the parse tree has a polynomial number of nodes there are only a
polynomial number of steps. However, how bad can 1 of those steps be in
the worst case? That is, how much time can it take to check a condition?
Is it linear with respect to the input (which includes: the attribute
grammar, and the certificate)?

To examine this we will start with the leaves of the parse tree. Each
leaf is a Terminal Symbol. A constant number of attributes can be
produced by a single terminal symbol. We denote this number as $C$.
Therefore, there can be at most $C$ actions and $C^2 D$ terms in the
condition --- where $D$ is the number of binary comparison operators in
the language.

Most importantly, if the condition actually has $C^2 D$ terms every term
has to be written down. So checking the truth value of the condition is
linear with respect to the size of the attribute grammar. If loops or
quantifiers such as $\exists$ and $\forall$ are allowed this no longer
holds. However, since we do not allow quantification in the conditions
checking a leaf condition (and indeed any condition) must be linear with
respect to the size of the input.

At internal nodes the number of terms in a condition could be as high as
$(2^{h-2}C)^2 D$ where $h$ is the height of the subtree rooted at the
current node. Once again, while this is clearly an exponential number,
it is not exponential with respect to the input as each term is part of
the input.

\subparagraph{Therefore,}

checking all conditions are satisfied is polynomial time as long as
quantifiers are disallowed from conditions.

